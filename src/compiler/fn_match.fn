
match = fn ([]) {
    []
} ([_:_] = List) {
    match_list(List)
} ((integer _ _) = Ast) {
    Ast
} ((float _ _) = Ast) {
    Ast
} ((atom _ _) = Ast) {
    Ast
} ((char _ _) = Ast) {
	Ast
} ((string _ _) = Ast) {
	Ast
} ((var _ _) = Ast) {
	Ast
} ((nil _) = Ast) {
	Ast
} (default) {
	default
} ((cons Line A B)) {
	fn_gen.cons(Line match(A) match(B))
} ((tuple Line A)) {
	fn_gen.tuple(Line match_list(A))
} ( ('+' = Op, Line A B) ) {
    fn_gen.expr(Op Line match(A) match(B))
} ( ('-' = Op Line A B) ) {
    fn_gen.expr(Op Line match(A) match(B))
} ( ('*' = Op, Line A B) ) {
    fn_gen.expr(Op Line match(A) match(B))
} ( ('/' = Op, Line A B) ) {
    fn_gen.expr(Op Line match(A) match(B))
} ( ('%' Line A B) ) {
    fn_gen.expr('rem' Line match(A) match(B))
} ( ('++' = Op, Line A B) ) {
    fn_gen.expr(Op Line match(A) match(B))
} ( ('--' = Op, Line A B) ) {
    fn_gen.expr(Op Line match(A) match(B))
} ( ('<<' Line A B) ) {
    fn_gen.expr('bsl' Line match(A) match(B))
} ( ('>>' Line A B) ) {
    fn_gen.expr('bsr' Line match(A) match(B))
} ( ('<' = Op, Line A B) ) {
    fn_gen.expr(Op Line match(A) match(B))
} ( ('<=' Line A B) ) {
    fn_gen.expr('=<' Line match(A) match(B))
} ( ('==' = Op Line A B) ) {
    fn_gen.expr(Op Line match(A) match(B))
} ( ('===' Line A B) ) {
    fn_gen.expr('=:=' Line match(A) match(B))
} ( ('>=' = Op Line A B) ) {
    fn_gen.expr(Op Line match(A) match(B))
} ( ('>' = Op Line A B) ) {
    fn_gen.expr(Op Line match(A) match(B))
} ( ('!=' Line A B) ) {
    fn_gen.expr('/=' Line match(A) match(B))
} ( ('!==' Line A B) ) {
    fn_gen.expr('=/=' Line match(A) match(B))
} ( ('!' = Op Line A B) ) {
    fn_gen.expr(Op Line match(A) match(B))
} ( ('|' Line A B) ) {
    fn_gen.expr('bor' Line match(A) match(B))
} ( ('&' Line A B) ) {
    fn_gen.expr('band' Line match(A) match(B))
} ( ('^' Line A B) ) {
    fn_gen.expr('bxor' Line match(A) match(B))
} ( ('andd' Line A B) ) {
    fn_gen.expr('and' Line match(A) match(B))
} ( ('orr' Line A B) ) {
    fn_gen.expr('or' Line match(A) match(B))
} ( ('and' Line A B) ) {
    fn_gen.expr('andalso' Line match(A) match(B))
} ( ('or' Line A B) ) {
    fn_gen.expr('orelse' Line match(A) match(B))
} ( ('xor' Line A B) ) {
    fn_gen.expr('xor' Line match(A) match(B))
} ( ('not' = Op Line A) ) {
    fn_gen.expr(Op Line match(A))
} ( ('~' Line A) ) {
    fn_gen.expr('bnot' Line match(A))
} ( ('+' _Line A) ) {
    match(A)
} ( ('-' = Op Line A) ) {
    fn_gen.expr(Op Line match(A))
} ( ('(' _Line A) ) {
    match(A)
} ( ('fun' _Line, (function _Name _Arity)) = Expr) {
    Expr
} ( ('fun' _Line, (function _Module _Name _Arity)) = Expr) {
    Expr
} ( ('bin'=Op Line BinElements) ) {
    fn_gen.op(Line Op match_list(BinElements))
} ( ('bin_element'=Op Line Value Size Types) ) {
    fn_gen.op(Line Op match(Value) match(Size) Types)
} ( (lc=Op Line Exp Generators) ) {
    fn_gen.op(Line Op match(Exp) match_list(Generators))
} ( (generate=Op Line For In) ) {
    fn_gen.op(Line Op match(For) match(In))
} ( (generate=Op Line For In If) ) {
    fn_gen.op(Line Op match(For) match(In) match(If))
} ( (bc=Op Line Exp Generators) ) {
    (Op Line match(Exp) match_list(Generators))
} ( (b_generate=Op Line For In) ) {
    (Op Line match(For) match(In))
} ( (b_generate=Op Line For In If) ) {
    (Op Line match(For) match(In) match(If))
} ( (call Line [Function] Args) ) {
    fn_gen.call(Line match(Function) match_list(Args))
} ( (call Line [Package Function] Args) ) {
    fn_gen.call(Line match(Package) match(Function) match_list(Args))
} ( (arrow_call Line Expr [(_ Function Args)]) ) {
    fn_gen.call(Line match(Function) [match(Expr):match_list(Args)])
} ( (arrow_call Line Expr [(_ Module Function Args)]) ) {
    fn_gen.call(Line match(Module) match(Function) [match(Expr):match_list(Args)])
} ( (arrow_call Line Expr [(_ Function Args):T]) ) {
    FirstCall = fn_gen.call(Line match(Function) [match(Expr):match_list(Args)])
    chain_call(FirstCall T)
} ( (arrow_call Line Expr [(_ Module Function Args):T]) ) {
    FirstCall = fn_gen.call(Line match(Module) match(Function) [match(Expr):match_list(Args)])
    chain_call(FirstCall T)
} ( ('=' Line A B) ) {
    fn_gen.match(Line match(A) match(B))
} ( ('fn' Line Patterns) ) {
    fn_gen.fun_def(Line match_fun_body(Patterns))
} ( (fun_def Line Name, ('fn' _Line Patterns) ) ) {
    fn_gen.func_def(Line Name get_function_arity(Patterns) match_function_body(Patterns))
} ( (obj_def Line Name Fields) ) {
    fn_record.build(Line Name Fields)
} ( ('receive' Line Patterns) ) {
    fn_gen.receive_expr(Line match_list(Patterns))
} ( ('receive' Line Patterns After, ('{' _ AfterBody) ) ) {
    fn_gen.receive_expr(Line match_list(Patterns) match(After) match(AfterBody))
} ( ('try' Line, ('{' _ TryBody) CatchPatterns) ) {
    fn_gen.try_expr(Line match(TryBody) match_function_body(CatchPatterns))
} ( ('try' Line, ('{' _ TryBody) CatchPatterns, ('{' _ FinallyBody) ) ) {
    fn_gen.try_expr(Line match(TryBody) match_function_body(CatchPatterns) match(FinallyBody))
} ( ('if' Line Patterns) ) {
    fn_gen.if_expr(Line match_function_body(Patterns))
} ( ('case' Line Condition Patterns) ) {
    fn_gen.case_expr(Line match(Condition) match_list(Patterns))
} ( (clause Line Pattern [] ('{' _BodyLine Body) ) ) {
    fn_gen.clause(Line match_list(Pattern) [] match_list(Body))
} ( (clause Line Pattern Guard, ('{' _BodyLine Body) ) ) {
    fn_gen.clause(Line match_list(Pattern) [match(Guard)] match_list(Body))
} ( ('record' Line Name Var Field) ) {
    fn_gen.rec_field(Line Name match(Var) match(Field))
} ( (record_set Line Name Var Fields) ) {
    fn_gen.record(Line Name match(Var) match_list(Fields))
} ( (record_new Line Name Fields) ) {
    fn_gen.record(Line Name match_list(Fields))
} ( (attr_set Line Name Expr) ) {
    # {record_field,LINE,Rep(Field_k),Rep(E_k)}
    fn_gen.rec_field(Line match(Name) match(Expr))
} (Exp) {
    (error Exp)
}

match_list = fn ([]) {
    []
} (Items) {
    match_list(Items [])
}

match_list = fn ([] Accum) {
    lists.reverse(Accum)
} ([Head : Tail] Accum) {
    match_list(Tail [match(Head) : Accum])
}

match_fun_body = fn (Patterns) {
    fn_gen.clauses(match_function_body(Patterns))
}

match_function_body = fn (Patterns) {
    match_function_body(Patterns [])
}

match_function_body = fn ([] Clauses) {
    lists.reverse(Clauses)
} ([Pattern : Patterns] Clauses) {
     match_function_body(Patterns [match_pattern(Pattern) : Clauses])
}

match_pattern = fn ( (pattern nil, ('(' Line Guard) ('{' _Line Body) ) ) {
     fn_gen.clause(Line [] [match_list(Guard)] match_list(Body))
} ( (pattern, ('(' Line Args) [] ('{' _ Body) ) ) {
     fn_gen.clause(Line [match(Arg) for Arg in Args] [] match_list(Body))
} ( (pattern, ('(' Line Args) Guards, ('{' _ Body) ) ) {
     fn_gen.clause(Line [match(Arg) for Arg in Args] [match_list(Guards)] match_list(Body))
}

get_function_arity = fn ([]) {
    0
} ([(pattern, ('(' _Line Arguments) _ _):_T]) {
    length(Arguments)
}

chain_call = fn (Expr [(Line Function Args)]) {
    # dont match Expr it's already matched
    fn_gen.call(Line match(Function) [Expr:match_list(Args)])
} (Expr [(Line Module Function Args)]) {
    # dont match Expr it's already matched
    fn_gen.call(Line match(Module) match(Function) [Expr:match_list(Args)])
} (Expr [(Line Function Args):T]) {
    # dont match Expr it's already matched
    Call = fn_gen.call(Line match(Function) [Expr:match_list(Args)])
    chain_call(Call T)
} (Expr [(Line Module Function Args):T]) {
    # dont match Expr it's already matched
    Call = fn_gen.call(Line match(Module) match(Function) [Expr:match_list(Args)])
    chain_call(Call T)
}
