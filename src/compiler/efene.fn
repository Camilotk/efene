
get_ast = fn (From String) {
    Ast = lists.map(fn (Line) { fn_match.match(Line) } get_tree(From String))

    if From == string {
        Ast
    } From == file {
        fn_gen.module(get_module_name(String) flatten1level(Ast))
    }
}

print_ast = fn (From String) {
    io.format("~p~n" [get_ast(From String)])
}

get_code = fn (Ast) {
    (ok _ Code) = compile.forms(Ast)
    Code
}

build_module = fn (ModuleName Ast) {
    (module Module) = code.load_binary(ModuleName ModuleName get_code(Ast))
    Module
}

to_erlang = fn (From String) {
    Ast = get_ast(From String)
    erl_prettypr.format(erl_syntax.form_list(Ast))
}

to_efene = fn (From String) {
    Ast = get_ast(From String)
    fn_prettypr.format(erl_syntax.form_list(Ast))
}

print_erlang = fn ([File]) {
    print_erlang(file File)
}

print_erlang = fn (From String) {
    io.format("~s~n" [to_erlang(From String)])
}

print_efene = fn ([File]) {
    print_efene(file File)
}

print_efene = fn (From String) {
    io.format("~s~n" [to_efene(From String)])
}

from_erlang = fn (Name) {
    (ok Content) = file.read_file(Name)
    Program = binary_to_list(Content)
    (ok Scanned _) = erl_scan.string(Program)
    (ok Parsed) = erl_parse.parse_form(Scanned)
    Parsed
}

print_from_erlang = fn (Name) {
    io.format("~p~n" [from_erlang(Name)])
}

build = fn (From String) {
    ModuleName = get_module_name(String)
    build_module(ModuleName get_ast(From String))
}

compile = fn (Name) {
    compile(Name ".")
}

compile = fn (Name Dir) {
    Module = get_code(get_ast(file Name))
    Path = filename.join([Dir get_module_beam_name(Name)])
    (ok Device) = file.open(Path [binary write])
    file.write(Device Module)
}

flatten1level = fn (List) {
    flatten1level(List [])
}

flatten1level = fn ([] Result) {
    lists.reverse(Result)
} ([Head:Tail] Result) when is_list(Head) {
    flatten1level(Tail lists.append(lists.reverse(Head) Result))
} ([Head:Tail] Result) {
    flatten1level(Tail [Head:Result])
}

get_tree = fn (From String) {
    Tokens = get_lex(From String)
    (ok Tree) = parser.parse(Tokens)
    Tree
}

print_tree = fn (From String) {
    io.format("~p~n" [get_tree(From String)])
}

get_lex = fn (string String) {
    (ok Tokens _Endline) = lexer.string(String)
    Tokens
} (file Name) {
    (ok Content) = file.read_file(Name)
    Program = binary_to_list(Content)
    (ok Tokens _Endline) = lexer.string(Program)
    Tokens
}

print_lex = fn (From String) {
    io.format("~p~n" [get_lex(From String)])
}

get_module_name = fn (String) {
    File = filename.basename(String)
    ModuleNameStr  = filename.rootname(File)
    list_to_atom(ModuleNameStr)
}

get_module_beam_name = fn (String) {
    File = filename.basename(String)
    ModuleNameStr  = filename.rootname(File)
    string.concat(ModuleNameStr ".beam")
}

eval_expression = fn (Expression Lang) {
    Bindings = erl_eval.new_bindings()
    try {
        Ast = get_ast(string Expression ++ "\n")
        (_ Result _) = erl_eval.exprs(Ast Bindings)
        if Lang == efene {
            io.format(">>> ~s~n~p~n" [Expression Result])
        } Lang == erlang {
            io.format("1> ~s~n~p~n" [erl_prettypr.format(erl_syntax.form_list(Ast)) Result])
        }
    } catch _ Error {
        io.format("~p~n" [Error])
    }
}

compile_file = fn (Dir File) {
    try {
        io.format("compiling ~s~n" [File])
        compile(File Dir)
    } catch _ Error {
        display_error(Error)
    }
}

compile_files = fn (Dir [File]) {
    compile_file(Dir File)
} (Dir [File:Files]) {
    compile_file(Dir File)
    compile_files(Dir Files)
}

# command line functions

main = fn (["beam" Dir:Files]) {
    compile_files(Dir Files)
} (["ast" _Dir File]) {
    print_ast(file File)
} (["tree" _Dir File]) {
    print_tree(file File)
} (["lex" _Dir File]) {
    print_lex(file File)
} (["erl" _Dir File]) {
    print_erlang([File])
} (["fn" _Dir File]) {
    print_efene([File])
} (["erl2ast" _Dir File]) {
    print_from_erlang(File)
} (["eval" Expression]) {
    eval_expression(Expression efene)
} (["eeval" Expression]) {
    eval_expression(Expression erlang)
} (["shell"]) {
    fn_shell.start()
} (Args) {
    io.format("Unknown arguments. ~p~n" [Args])
}

display_error = fn ( (badmatch, (error, (Line lexer, (illegal Character)) _)) )  {
    io.format("~B. Illegal character '~s'~n" [Line Character])
} ( (badmatch, (error, (Line parser [Message Item]))) ) {
    io.format("~B. ~s~s~n" [Line Message Item])
} (Unknown) {
    io.format("Error. ~p~n" [Unknown])
}


