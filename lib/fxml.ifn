@@license("New BSD License, part of efene, see LICENSE for details")

@@moddoc("module to transform a tuple list data structure to xml string.
see examples/xml.ifn for usage examples")

@public
@doc("render a dict like data structure to a xml string")

xml = fn (Dct) when is_list(Dct)
    xml(Dct, [], [new_line, indent => 1], 0)

fn (Dct)
    xml([Dct], [], [new_line, indent => 1], 0)

@public
@doc("like xml/1 but specifying formatting options")

xml = fn (Dct, Options)
    xml(Dct, [], Options, 0)

xml = fn ([], Result, _Options, _Level)
    lists.reverse(Result)

fn ([Tag:Tail], Result, Options, Level)
    xml(Tail, [tag(Tag, Options, Level):Result], Options, Level)

@public
@doc("format a tag")

tag = fn (Tag)
    tag(Tag, [], 0)

@public
tag = fn (Tag, Options)
    tag(Tag, Options, 0)

tag = fn (Tag => Props, Options, Level)
    Attrs = get(attrs, Props, nil)
    Items = get(items, Props, nil)
    Body  = get(body,  Props, nil)
    Close = get(close, Props, tag)
    NewLine = get_new_line(Options)

    if Items != nil and Body != nil
        throw(invalid_tag => "items and body can't be in the same tag")
    else
        tag(Tag, Attrs, Items, Body, Close, NewLine, Options, Level)

fn (Tag, Options, Level) when is_atom(Tag)
    tag(Tag => [], Options, Level)


tag = fn (Tag, nil, nil, nil, Close, NewLine, Options, Level)
    (StrTag, Indent) = get_tag_data(Tag, Options, Level)

    switch Close
        case tag
            io_lib.format("~s<~s></~s>~s", [Indent, StrTag, StrTag, NewLine])
        case self
            io_lib.format("~s<~s />~s", [Indent, StrTag, NewLine])
        case none
            io_lib.format("~s<~s>~s", [Indent, StrTag, NewLine])

fn (Tag, nil, nil, Body, _Close, NewLine, Options, Level)
    (StrTag, Indent) = get_tag_data(Tag, Options, Level)
    io_lib.format("~s<~s>~s</~s>~s", [Indent, StrTag, to_str(Body),
        StrTag, NewLine])

fn (Tag, nil, Items, nil, _Close, NewLine, Options, Level)
    (StrTag, Indent) = get_tag_data(Tag, Options, Level)
    io_lib.format("~s<~s>~s~s~s</~s>~s",
        [Indent, StrTag, NewLine, xml(Items, [], Options, Level + 1), Indent,
            StrTag, NewLine])

fn (Tag, Attrs, nil, nil, Close, NewLine, Options, Level)
    (StrTag, Indent) = get_tag_data(Tag, Options, Level)

    switch Close
        case tag
            io_lib.format("~s<~s~s></~s>~s", [Indent, StrTag, attrs(Attrs),
                StrTag, NewLine])
        case self
            io_lib.format("~s<~s~s />~s", [Indent, StrTag, attrs(Attrs),
                NewLine])
        case none
            io_lib.format("~s<~s~s>~s", [Indent, StrTag, attrs(Attrs),
                NewLine])

fn (Tag, Attrs, nil, Body, _Close, NewLine, Options, Level)
    (StrTag, Indent) = get_tag_data(Tag, Options, Level)
    io_lib.format("~s<~s~s>~s</~s>~s",
        [Indent, StrTag, attrs(Attrs), to_str(Body), StrTag, NewLine])

fn (Tag, Attrs, Items, nil, _Close, NewLine, Options, Level)
    (StrTag, Indent) = get_tag_data(Tag, Options, Level)
    io_lib.format("~s<~s~s>~s~s~s</~s>~s",
        [Indent, StrTag, attrs(Attrs), NewLine,
         xml(Items, [], Options, Level + 1), Indent, StrTag, NewLine])


get_tag_data = fn (Tag, Options, Level)
    (to_str(Tag), get_indent(Options, Level))

is_new_line = fn (Options)
    lists.member(new_line, Options)

get_new_line = fn (Options)
    if is_new_line(Options)
        "\n"
    else
        ""

get_indent = fn (Options, Level)
    switch lists.keyfind(indent, 1, Options)
        case false
            ""
        case indent => Val
            lists.duplicate(Val * Level, " ")

@public
attrs = fn ([])
    ""

fn (Attrs)
    attrs(Attrs, [])

@public
attrs = fn ([], Result)
    lists.append(lists.reverse(Result))

fn ([Attr => Value:Tail], Result)
    attrs(Tail, [attr(Attr => Value):Result])

@public
attr = fn (Attr => Value)
    io_lib.format(" ~s=\"~s\"", [to_str(Attr), to_str(Value)])

@public
@doc("convert basic data types to string")
to_str = fn (Val) when is_list(Val)
    Val

fn (Val)
    io_lib.format("~p", [Val])

@public
get = fn (Attr, Attrs, Default)
    switch lists.keyfind(Attr, 1, Attrs)
        case false
            Default
        case Attr => Value
            Value
