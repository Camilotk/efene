@@license("New BSD License, part of efene, see LICENSE for details")
@@moddoc("module to manipulate struct data structures")

not_found = fn (_Struct, Name)
    throw(attribute_error => "struct has no attribute '" ++ atom_to_list(Name) ++ "'")

@doc("function called from get when the attribute wasn't found on the struct,
look if there is a proto_ attribute and look inside it to search for the
value")
not_found_proto = fn (Struct, Name) when is_atom(Name)
    if Struct.proto_?
        get(Struct.proto_, Name)
    else
        not_found(Struct, Name)

@doc("throw an exception stating that the value is not a valid struct")
not_struct = fn (Val)
    throw(value_error => io_lib.format("value ~p doesn't seem to be a struct", [Val]))

get_found = fn (_Struct, _Name, Value)
    Value

@public
@doc("return true if the parameter is a valid struct, false otherwise")
is_struct = fn ((struct, Values)) when is_list(Values)
    true

fn (_)
    false

@public
@doc("access the value of an attribute in a struct, if not found in the struct
look inside the proto_ attribute recursively")

get = fn (Struct, Names)
    get_h(Struct, Names, fn not_found_proto:2)

@public
@doc("access the value of an attribute in a struct, if not found in the struct, fail")

getown = fn (Struct, Names)
    get_h(Struct, Names, fn not_found:2)

@doc("internal helper to get a value and do something if not found")
get_h = fn (Struct, [], _FnNotFound)
    Struct

fn (Struct, [Name:Names], FnNotFound)
    get_h(get_h(Struct, Name, FnNotFound), Names, FnNotFound)

fn (Struct, Name, FnNotFound) when is_atom(Name)
    do(Struct, Name, fn get_found:3, FnNotFound)

@public
@doc("replace the value of an attribute in a struct")
set = fn ((struct, Body)=Struct, [Name], Value)
    if lists.keymember(Name, 1, Body)
        (struct, lists.keyreplace(Name, 1, Body, Name => Value))
    else
        not_found(Struct, Name)

fn ((struct, Body)=Struct, [Name:Names], Value)
    NewChild = set(get(Struct, [Name]), Names, Value)
    (struct, lists.keyreplace(Name, 1, Body, Name => NewChild))

fn (Struct, Name, Value) when is_atom(Name)
    set(Struct, [Name], Value)

fn (_, _Names, _Value)
    throw(value_error => "value doesn't seem to be a struct")

@public
@doc("return a pretty representation of a struct")
format = fn (Struct)
    format(Struct, false)

format = fn ((struct, Body), ShowFuns)
    Items = for Key => Val in Body if not is_function(Val) or ShowFuns
        if Key == proto_
            ""
        else if schema.is_object(Val)
            io_lib.format("~p: ~s, ", [Key, format(Val, ShowFuns)])
        else
            io_lib.format("~p: ~s, ", [Key, fio.format(Val)])

    Items1 = lists.flatten(Items)
    Items1Len = length(Items1)

    if Items1Len == 0
        io_lib.format("{}")
    else
        # TODO: seems to enter here with Items1Len == 0 (?)
        io_lib.format("{~s}", [lists.sublist(Items1, Items1Len - 2)])

@public
@doc("pretty print a struct")
print = fn (Struct)
    print(Struct, false)

@public
@doc("pretty print a struct")
print = fn (Struct, ShowFuns)
    io.format("~s~n", [format(Struct, ShowFuns)])

has_not_found = fn ((struct, Body)=Struct, FName)
    # avoid calling has or has_h inside a call to has or has_h ;)
    if lists.keyfind(proto_, 1, Body) != false
        has_h(Struct.proto_, FName, fn has_not_found:2)
    else
        false

@public
@doc("return true if the struct has the given attribute as atom or string,
false otherwise.

if not found on its attributes, look on parent ones

the second parameter must be an atom or a list of atoms/strings")

has = fn (Struct, Names)
    FnNotFound = fn has_not_found:2
    has(Struct, Names, FnNotFound)

has = fn (_Struct, [], _FnNotFound)
    true

fn (Struct, [Name:Names], FnNotFound)
    switch has_h(Struct, Name, FnNotFound)
        case true => Value
            has(Value, Names, FnNotFound)
        case false
            false

fn (Struct, Name, FnNotFound) when is_atom(Name)
    has(Struct, [Name], FnNotFound)

@public
has_h = fn (Struct, Name)
    FnNotFound = fn has_not_found:2
    has_h(Struct, Name, FnNotFound)


has_h = fn (Struct, Name, FnNotFound)
    FnFound = fn (_Struct, _Name, Value)
        true => Value

    FnNotStruct = fn (_Val)
        false

    do(Struct, Name, FnFound, FnNotFound, FnNotStruct)

@public
@doc("return true if the struct has the given attribute as atom or string,
false otherwise.

only looks on it's attributes, doesn't look in parent ones

the second parameter must be an atom or a list of atoms/strings")
hasown = fn (Struct, Names)
    FnNotFound = fn (_Struct, _Name)
        false

    has(Struct, Names, FnNotFound)

@public
@doc("return all the field names of a struct.

the types are preserved, so if a struct has some string keys (posible if
decoding json) then those keys will be returned as strings.

it's your job to check that. This is done this way to avoid creating atoms
")
fields = fn ((struct, Body))
    [Key for (Key, _Val) in Body if Key != proto_]

fn (Val)
    not_struct(Val)

@public
@doc("extend the struct by adding an attribute named *Key* with value *Value*")
extend = fn ((struct, Body), Key, Value)
    if is_atom(Key) or is_list(Key)
        (struct, [Key => Value:Body])
    else
        throw(value_error => "key isn't a string or an atom")

fn (_, _Key, _Value)
    throw(value_error => "value doesn't seem to be a struct")

@public
@doc("return the prototype for a basic struct that can do the operations
defined in this module")
prototype = fn ()
    Get = fn get:2
    GetOwn = fn getown:2
    Has = fn has:2
    HasOwn = fn hasown:2
    Set = fn set:3
    Fields = fn fields:1
    Extend = fn extend:3
    Format = fn format:1
    Print  = fn print:1
    ToPList = fn to_plist:1

    {get: Get, getown: GetOwn, has: Has, hasown: HasOwn, set: Set,
        fields: Fields, extend: Extend, format: Format, print: Print,
        to_plist: ToPList}

@public
@doc("set the default prototype to Struct")
set_prototype = fn (Struct)
    set_prototype(Struct, prototype())

@public
@doc("set the givent prototype to Struct")
set_prototype = fn (Struct, Prototype)
    extend(Struct, proto_, Prototype)

@public
@doc("look for an attribute and call a function when found")
do = fn (Struct, Name, FoundFn)
    do(Struct, Name, FoundFn, fn not_found:2)

@public
@doc("look for an attribute and call a function when found, and other if not
found.

if *Name* is an atom and it's not found it will convert the atom to a string
and check again using the string as key.

if *Name* is a string it will only check for the key a string since atoms
aren't garbage collected we don't want to be creating atoms for every attribute
lookup.

the FoundFn function will be called with the following parameters:
 * Struct: the struct passed as parameter
 * Name: the name of the attribute as passed to this function (atom or string)
 * Value: the found value of the attribute

the NotFoundFn function will be called with the following parameters:
 * Struct: the struct passed as parameter
 * Name: the name of the attribute as passed to this function (atom or string)
")
do = fn (Struct, Name, FoundFn, NotFoundFn)
    do(Struct, Name, FoundFn, NotFoundFn, fn not_struct:1)

@public
@doc("like do/4 but with a callback to be called when the parameter is not a struct")
do = fn ((struct, Body)=Struct, Name, FoundFn, NotFoundFn, _NotStruct)
    switch lists.keyfind(Name, 1, Body)
        case false
            if is_atom(Name)
                StrName = atom_to_list(Name)

                switch lists.keyfind(StrName, 1, Body)
                    case false
                        NotFoundFn(Struct, Name)
                    case _ => Value
                        FoundFn(Struct, Name, Value)

            else
                NotFoundFn(Struct, Name)
        case _ => Value
            FoundFn(Struct, Name, Value)

fn (Val, _Name, _FoundFn, _NotFoundFn, NotStruct)
    NotStruct(Val)

@public
@doc("return a prop list with the attributes of the struct, this function
doesn't return attributes that are functions or the proto_ attribute")
to_plist = fn ((struct, Body))
    Filter = fn ((Key, Val))
        Key != proto_ and not is_function(Val) and Key != "proto_"

    lists.filter(Filter, Body)

fn (Val)
    not_struct(Val)

@public
@doc("return a struct that contains the values provided by the proplist")

from_plist = fn (PList) when is_list(PList)
    Check = fn (_Key => _Val)
        true

    fn (_)
        false

    if lists.all(Check, PList)
        (struct, PList)
    else
        throw(value_error => "parameter is not a valid proplist")

fn (_)
    throw(value_error => "parameter is not a valid proplist")
