@@moddoc("Module to do operation on efene objects.

This module has some functions that expect the result of mochijson2.decode
function but mochiweb is not installed by default by efene, you should get
mochiweb or at least mochijson2 or a compatible json encoder/decoder in order
to use those functions.")

@@todo("refine types and specs and add the missing ones")

@doc("return a list of two item tuples containing as key the name of the
attribute as string and as value the value of that attribute")

@public
to_dict = fn (Obj)
    to_dict(Obj, strkeys)

@doc("load info to Obj from a Struct like the one returned by mochijson2.decode
returns a tuple with the object as first element and a list of the attributes
(as string) that were found and set in the object as the second element")

@public
from_json = fn ((struct, Data), Obj)
    from_json(Data, Obj, [], false)

@doc("same as from_json/2 but pass a boolean asking if we want to transform
binaries to lists")

@public
from_json = fn ((struct, Data), Obj, BinaryToList)
    from_json(Data, Obj, [], BinaryToList)


from_json = fn ([], Obj, Attrs, _BinaryToList)
    (Obj, Attrs)

fn ([(Key, Value):Data], Obj, Attrs, BinaryToList)
    SKey = binary_to_list(Key)

    FValue = when BinaryToList
        when is_binary(Value)
            binary_to_list(Value)
        else
            Value
    else
        Value

    switch Obj(has, SKey)
        case true
            AKey = list_to_atom(SKey)
            from_json(Data, Obj((set, AKey), FValue), [SKey:Attrs], BinaryToList)
        else
            from_json(Data, Obj, Attrs, BinaryToList)

@doc("return a json representation of a list of objects")

@public
objs_to_json = fn (Objs)
    StrObjs = lists.map(fn (Obj) { to_json(Obj) }, Objs)
    Items = [io_lib.format("~s, ", [StrObj]) for StrObj in StrObjs]
    Str = lists.flatten(Items)
    "[" ++ lists.sublist(Str, length(Str) - 2) ++ "]"

@doc("return a list of two item tuples containing as key the name of the
attribute as string or atom depending on the second parameter (atomkeys,
strkeys) and as value the value of that attribute")

@public
to_dict = fn (Obj, atomkeys)
    [(Name, Obj(get, Name)) for Name in Obj(to, fieldslist)]

fn (Obj, strkeys)
    [(atom_to_list(Name), Obj(get, Name)) for Name in Obj(to, fieldslist)]

@doc("return a string with the JSON representation of Obj")

@public
to_json = fn(Obj)
    Items = [io_lib.format("~p: ~s, ", [Name, transform(Value)]) for (Name, Value) in to_dict(Obj)]
    Str = lists.flatten(Items)
    "{" ++ lists.sublist(Str, length(Str) - 2) ++ "}"

@doc("receives an object as first parameter and a data structure that specified
the validations to be done on each attribute and the string to return if the
validation fails.

The data structure is a list of tuples, each tuple has as first element the
name of the attribute and as second element a list of two item tuples that
contain the validation function to use in the attribute and the string to be
returned if the validation fails.

example::

    obj.validate(User,
        [(username,
            [(validate.string(), \"username must be a string\"),
            (validate.string_larger_than(2), \"username size must be at least 3 characters\"),
            (validate.match(\"^[a-z][a-zA-Z0-9_]+$\"), \"username must be alphanumeric and _ only\")]),
        (mail,
            [(validate.mail(), \"invalid mail format\")]),
        (password,
            [(validate.string(), \"password must be a string\"),
            (validate.string_larger_than(2), \"password size must be at least 3 characters\")])])

You can add as many validations for attribute and as many attributes you want.

returns ok when all validators pass (error, Reason) when one failed")

@public
validate = fn (_Obj, [])
    ok

fn (Obj, [(Attr, Validations):T])
    switch Obj(has, Attr)
        case true

            switch validate_attr(Obj(get, Attr), Validations)
                case ok
                    validate(Obj, T)
                case (error, _Reason)=Error
                    Error

        case false
            (error, io_lib.format("~s has no attribute ~s",
                [Obj(to, strname), Attr]))

validate_attr = fn (_Attr, [])
    ok

fn (Attr, [(Validator, Reason):T])
    switch Validator(Attr)
        case true
            validate_attr(Attr, T)
        case false
            (error, Reason)

@doc("transform values so that they are printed correctly by io_format as
valid json terms")

transform = fn (Value) when is_tuple(Value)
    io_lib.format("~p", [transform_tuple(Value)])
fn (Value) when is_boolean(Value)
    io_lib.format("~p", [Value])
fn (Value) when is_function(Value)
    to_json(Value)
fn (Value) when is_atom(Value)
    # TODO: see how to make atoms different from strings
    io_lib.format("\"~p\"", [Value])
fn (Value) when is_list(Value)
    io_lib.format("~p", [transform_tuple(Value, [])])
fn (Value) when is_binary(Value)
    io_lib.format("\"~s\"", [Value])
fn (Value)
    io_lib.format("~p", [Value])

@doc("transform tuples to lists recursively, also transform atoms to strings")

transform_tuple = fn (Tuple)
    transform_tuple(tuple_to_list(Tuple), [])

transform_tuple = fn ([], Accum)
    lists.reverse(Accum)
fn ([H:T], Accum) when is_tuple(H)
    transform_tuple(T, [transform_tuple(H):Accum])
fn ([H:T], Accum) when is_list(H)
    transform_tuple(T, [transform_tuple(H, []):Accum])
fn ([H:T], Accum) when is_boolean(H)
    transform_tuple(T, [H:Accum])
fn ([H:T], Accum) when is_atom(H)
    transform_tuple(T, [atom_to_list(H):Accum])
fn ([H:T], Accum)
    transform_tuple(T, [H:Accum])

@doc("copy the attributes from one object to a new one if the attributes are
pressent")

@public
copy = fn (Old, New)
    Attrs = [Attr for Attr in Old(to, fieldslist) if New(has, Attr)]
    set_attrs(Attrs, Old, New)

@doc("set the attributes from old to new")

set_attrs = fn ([], _Old, New)
    New

fn ([Attr:Attrs], Old, New)
    set_attrs(Attrs, Old, New((set, Attr), Old(get, Attr)))

@doc("return the AST of a clause to get the value of the field of a record::

    >>> obj.get_field(1, person, 'P', name)
    {clause,1,
            [{atom,1,get},{atom,1,name}],
            [],
            [{record_field,1,{var,1,'P'},record_name,{atom,1,name}}]}")

get_field = fn (Line, RecName, VarName, FieldName)

    ast.clause(Line, [|fn (get, field_name) { record_name.RecordVar[field_name] }|])->
        ast.replace_record(record_name, RecName, 'RecordVar', VarName, field_name, FieldName)->
        ast.replace_atom(field_name, FieldName)

@doc("return the AST of a clause to set the value of a record's field::

    >>> obj.set_field(42, person, 'P', name)
    {clause,42,
            [{atom,42,setname},{var,42,'Value'}],
            [],
            [{record,42,
                     {var,42,'P'},
                     person,
                     [{record_field,42,{atom,42,name},{var,42,'Value'}}]}]}")

set_field = fn (Line, RecName, VarName, FieldName)

    SetArg = list_to_atom("set" ++ atom_to_list(FieldName))

    ast.clause(Line, [|fn (setfield_name, Value) { Self(Self, record_name.RecordVar[field_name=Value]) }|])->
        ast.replace_record(record_name, RecName, 'RecordVar', VarName, field_name, FieldName)->
        ast.replace_atom(setfield_name, SetArg)->
        ast.replace_atom(field_name, FieldName)

@doc("return the AST of a clause to set the value of a record's field with the
first parameter as a tuple::

    >>> obj.set_field_tuple(42, person, 'P', name)
    {clause,42,
            [{tuple,42,[{atom,42,set},{atom,42,name}]},{var,42,'Value'}],
            [],
            [{record,42,
                     {var,42,'P'},
                     person,
                     [{record_field,42,{atom,42,name},{var,42,'Value'}}]}]}")

set_field_tuple = fn (Line, RecName, VarName, FieldName)

    ast.clause(Line, [|fn ((set, field_name), Value) { Self(Self, record_name.RecordVar[field_name=Value]) }|])->
        ast.replace_record(record_name, RecName, 'RecordVar', VarName, field_name, FieldName)->
        ast.replace_atom(field_name, FieldName)

@doc("return the a list of ASTs with all the special clauses of an object")

get_special = fn (Line, Name, Fields)

    SpecialAtom = list_to_atom("$" ++ atom_to_list(atom_to_upper(Name)))

    AtomName    = ast.to_ast(Line, Name)
    StrName     = (string, Line, atom_to_list(Name))
    VarName     = ast.to_ast(Line, SpecialAtom, true)
    FieldList   = ast.to_ast(Line, tuple_to_list(Fields))
    FieldTuple  = ast.to_ast(Line, Fields)

    Ast = [|fn (to, rec)
        $(VarName)
    fn (to, fields)
        $(FieldTuple)
    fn (to, fieldslist)
        $(FieldList)
    fn (to, name)
        $(AtomName)
    fn (to, strname)
        $(StrName)
    fn (has, Name) when is_atom(Name)
        lists.member(Name, $(FieldList))
    fn (has, Name) when is_list(Name)
        lists.member(list_to_atom(Name), $(FieldList))
    fn (has, _)
        false
    fn (A, B)
        throw((method_not_found, A, B))
    |]

    ast.clauses(Line, Ast)

#@spec(Line :: integer(), Name :: atom(), Fields :: tuple(atom())) -> ast.ast()
@doc("return the AST of the closure that represents an object")

closure = fn (Line, Name, Fields)
    FieldList = tuple_to_list(Fields)

    VarName     = atom_to_upper(Name)
    SpecialAtom = atom_to_var(Name)
    VarNameAst  = ast.to_ast(Line, SpecialAtom, true)

    Gets = [get_field(Line, Name, VarName, Field) for Field in FieldList]
    Sets = [set_field(Line, Name, VarName, Field) for Field in FieldList]
    Sett = [set_field_tuple(Line, Name, VarName, Field) for Field in FieldList]
    Specials = get_special(Line, Name, Fields)

    Clauses = Gets ++ Sets ++ Sett ++ Specials
    Inner = ast.clauses_to_fun(Line, Clauses)
    [|fn (Self, $(VarNameAst)) { $(Inner) }|]

atom_to_upper = fn (Atom)
    [FirstChar:Rest] = atom_to_list(Atom)
    list_to_atom([string.to_upper(FirstChar)] ++ Rest)

atom_to_var = fn (Atom)
    list_to_atom("$" ++ atom_to_list(atom_to_upper(Atom)))

@public
#@spec(Line :: integer(), Name :: atom(), Fields :: tuple(atom())) -> ast.asts()
@doc("return the AST for an object")

new = fn (Line, Name, Fields)
    # [firtname, lastname, mail]
    FieldList   = tuple_to_list(Fields)
    # person = record(firstname, lastname, mail)
    RecDef      = ast.rec(Line, Name, FieldList)
    # [firtname=Firstname, lastname=Lastname, mail=Mail]
    RecFields   = [(Field, atom_to_var(Field)) for Field in FieldList]
    # person[firtname=Firstname, lastname=Lastname, mail=Mail]
    RecMatch    = ast.rec_match(Line, Name, RecFields)
    # fn (Self, Person) { ... }
    Wrapper     = closure(Line, Name, Fields)
    # @public
    Public      = ast.public(Line)

    # [FirstName, LastName, Mail]
    FunArgs     = [(var, Line, atom_to_upper(Field)) for Field in FieldList]
    # person(FirstName, LastName, Mail)
    FunCall     = (call, Line, (atom, Line, Name), FunArgs)

    # person = fn (person[firtname=Firstname, lastname=Lastname, mail=Mail])
    #     person(FirstName, LastName, Mail)
    RecFun      = ast.set_fun_args([|fn () { $(FunCall) }|], [RecMatch])
    RecFunction = ast.function_from_fun(Line, Name, RecFun)

    # person = fn (FirstName, LastName, Mail)
    #     Obj = person[firtname=Firstname, lastname=Lastname, mail=Mail]
    #     Wrapper = fn (Self, Person) { ... }
    #     Wrapper(Wrapper, Obj)
    ArgFun = ast.set_fun_args([|fn ()
        Obj = $(RecMatch)
        Wrapper = $(Wrapper)
        Wrapper(Wrapper, Obj)
    |], FunArgs)

    ArgFunction = ast.function_from_fun(Line, Name, ArgFun)

    [RecDef, Public, RecFunction, Public, ArgFunction]
