
@doc("
return a list of two item tuples containing as key the name of the attribute as
string and as value the value of that attribute")

@public
to_dict = fn (Obj)
    to_dict(Obj, strkeys)

@doc("load info to Obj from a Struct like the one returned by mochijson2.decode
returns a tuple with the object as first element and a list of the attributes
(as string) that were found and set in the object as the second element")

@public
from_json = fn ((struct, Data), Obj)
    from_json(Data, Obj, [])

from_json = fn ([], Obj, Attrs)
    (Obj, Attrs)

fn ([(Key, Value):Data], Obj, Attrs)
    SKey = binary_to_list(Key)

    switch Obj(has, SKey)
        case true
            AKey = list_to_atom(SKey)
            from_json(Data, Obj((set, AKey), Value), [SKey:Attrs])
        else
            from_json(Data, Obj, Attrs)

@doc("return a json representation of a list of objects")

@public
objs_to_json = fn (Objs)
    StrObjs = lists.map(fn (Obj) { to_json(Obj) }, Objs)
    Items = [io_lib.format("~s, ", [StrObj]) for StrObj in StrObjs]
    Str = lists.flatten(Items)
    "[" ++ lists.sublist(Str, length(Str) - 2) ++ "]"

@doc("
return a list of two item tuples containing as key the name of the attribute as
string or atom depending on the second parameter (atomkeys, strkeys)
and as value the value of that attribute")

@public
to_dict = fn (Obj, atomkeys)
    [(Name, Obj(get, Name)) for Name in Obj(to, fieldslist)]

fn (Obj, strkeys)
    [(atom_to_list(Name), Obj(get, Name)) for Name in Obj(to, fieldslist)]

@doc("return a string with the JSON representation of Obj")

@public
to_json = fn(Obj)
    Items = [io_lib.format("~p: ~s, ", [Name, transform(Value)]) for (Name, Value) in to_dict(Obj)]
    Str = lists.flatten(Items)
    "{" ++ lists.sublist(Str, length(Str) - 2) ++ "}"

@doc("
transform values so that they are printed correctly by io_format
as valid json terms")

transform = fn (Value) when is_tuple(Value)
    io_lib.format("~p", [transform_tuple(Value)])
fn (Value) when is_boolean(Value)
    io_lib.format("~p", [Value])
fn (Value) when is_function(Value)
    to_json(Value)
fn (Value) when is_atom(Value)
    # TODO: see how to make atoms different from strings
    io_lib.format("\"~p\"", [Value])
fn (Value) when is_list(Value)
    io_lib.format("~p", [transform_tuple(Value, [])])
fn (Value) when is_binary(Value)
    io_lib.format("\"~s\"", [Value])
fn (Value)
    io_lib.format("~p", [Value])

@doc("transform tuples to lists recursively, also transform atoms to strings")

transform_tuple = fn (Tuple)
    transform_tuple(tuple_to_list(Tuple), [])

transform_tuple = fn ([], Accum)
    lists.reverse(Accum)
fn ([H:T], Accum) when is_tuple(H)
    transform_tuple(T, [transform_tuple(H):Accum])
fn ([H:T], Accum) when is_list(H)
    transform_tuple(T, [transform_tuple(H, []):Accum])
fn ([H:T], Accum) when is_boolean(H)
    transform_tuple(T, [H:Accum])
fn ([H:T], Accum) when is_atom(H)
    transform_tuple(T, [atom_to_list(H):Accum])
fn ([H:T], Accum)
    transform_tuple(T, [H:Accum])
