
@doc("
return a list of two item tuples containing as key the name of the attribute as
string and as value the value of that attribute")

@public
to_dict = fn (Obj)
    to_dict(Obj, strkeys)

@doc("load info to Obj from a Struct like the one returned by mochijson2.decode
returns a tuple with the object as first element and a list of the attributes
(as string) that were found and set in the object as the second element")

@public
from_json = fn ((struct, Data), Obj)
    from_json(Data, Obj, [], false)

@doc("same as from_json/2 but pass a boolean asking if we want to transform
binaries to lists")

@public
from_json = fn ((struct, Data), Obj, BinaryToList)
    from_json(Data, Obj, [], BinaryToList)


from_json = fn ([], Obj, Attrs, _BinaryToList)
    (Obj, Attrs)

fn ([(Key, Value):Data], Obj, Attrs, BinaryToList)
    SKey = binary_to_list(Key)

    FValue = if BinaryToList
        if is_binary(Value)
            binary_to_list(Value)
        else
            Value
    else
        Value

    switch Obj(has, SKey)
        case true
            AKey = list_to_atom(SKey)
            from_json(Data, Obj((set, AKey), FValue), [SKey:Attrs], BinaryToList)
        else
            from_json(Data, Obj, Attrs, BinaryToList)

@doc("return a json representation of a list of objects")

@public
objs_to_json = fn (Objs)
    StrObjs = lists.map(fn (Obj) { to_json(Obj) }, Objs)
    Items = [io_lib.format("~s, ", [StrObj]) for StrObj in StrObjs]
    Str = lists.flatten(Items)
    "[" ++ lists.sublist(Str, length(Str) - 2) ++ "]"

@doc("
return a list of two item tuples containing as key the name of the attribute as
string or atom depending on the second parameter (atomkeys, strkeys)
and as value the value of that attribute")

@public
to_dict = fn (Obj, atomkeys)
    [(Name, Obj(get, Name)) for Name in Obj(to, fieldslist)]

fn (Obj, strkeys)
    [(atom_to_list(Name), Obj(get, Name)) for Name in Obj(to, fieldslist)]

@doc("return a string with the JSON representation of Obj")

@public
to_json = fn(Obj)
    Items = [io_lib.format("~p: ~s, ", [Name, transform(Value)]) for (Name, Value) in to_dict(Obj)]
    Str = lists.flatten(Items)
    "{" ++ lists.sublist(Str, length(Str) - 2) ++ "}"

@doc("validate an object, receives an object, and a list of tuples containing
the attribute, and a list of functions that return true when the validation
passes and false if not, the next is the message to show in case of a
validation failure, for example:

validate(Obj, [(firstname, [(is_string, \"firstname must be a string\")]])

returns ok when all validators passed (error, Reason) when one failed
")

@public
validate = fn (_Obj, [])
    ok

fn (Obj, [(Attr, Validations):T])
    switch Obj(has, Attr)
        case true

            switch validate_attr(Obj(get, Attr), Validations)
                case ok
                    validate(Obj, T)
                case (error, _Reason)=Error
                    Error

        case false
            (error, io_lib.format("~s has no attribute ~s",
                [Obj(to, strname), Attr]))

validate_attr = fn (_Attr, [])
    ok

fn (Attr, [(Validator, Reason):T])
    switch Validator(Attr)
        case true
            validate_attr(Attr, T)
        case false
            (error, Reason)

@doc("
transform values so that they are printed correctly by io_format
as valid json terms")

transform = fn (Value) when is_tuple(Value)
    io_lib.format("~p", [transform_tuple(Value)])
fn (Value) when is_boolean(Value)
    io_lib.format("~p", [Value])
fn (Value) when is_function(Value)
    to_json(Value)
fn (Value) when is_atom(Value)
    # TODO: see how to make atoms different from strings
    io_lib.format("\"~p\"", [Value])
fn (Value) when is_list(Value)
    io_lib.format("~p", [transform_tuple(Value, [])])
fn (Value) when is_binary(Value)
    io_lib.format("\"~s\"", [Value])
fn (Value)
    io_lib.format("~p", [Value])

@doc("transform tuples to lists recursively, also transform atoms to strings")

transform_tuple = fn (Tuple)
    transform_tuple(tuple_to_list(Tuple), [])

transform_tuple = fn ([], Accum)
    lists.reverse(Accum)
fn ([H:T], Accum) when is_tuple(H)
    transform_tuple(T, [transform_tuple(H):Accum])
fn ([H:T], Accum) when is_list(H)
    transform_tuple(T, [transform_tuple(H, []):Accum])
fn ([H:T], Accum) when is_boolean(H)
    transform_tuple(T, [H:Accum])
fn ([H:T], Accum) when is_atom(H)
    transform_tuple(T, [atom_to_list(H):Accum])
fn ([H:T], Accum)
    transform_tuple(T, [H:Accum])
